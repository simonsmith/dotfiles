# Unified worktree + tmux management
# Requires: wtp (https://github.com/satococoa/wtp)

# Main wt dispatcher function
function wt() {
  if [[ $# -eq 0 ]]; then
    _wt_help
    return 0
  fi

  local subcommand="$1"
  shift

  case "$subcommand" in
    new)
      _wt_new "$@"
      ;;
    open)
      _wt_open "$@"
      ;;
    close)
      _wt_close "$@"
      ;;
    list)
      _wt_list "$@"
      ;;
    cd)
      _wt_cd "$@"
      ;;
    add)
      _wt_add "$@"
      ;;
    remove)
      _wt_remove "$@"
      ;;
    status)
      _wt_status "$@"
      ;;
    update)
      _wt_update "$@"
      ;;
    merge)
      _wt_merge "$@"
      ;;
    help|--help|-h)
      _wt_help
      ;;
    *)
      echo "Error: Unknown subcommand '$subcommand'"
      echo ""
      echo "Run 'wt help' for usage information"
      return 1
      ;;
  esac
}

# Show help and usage information
function _wt_help() {
  cat <<'EOF'
wt - Unified worktree management with tmux integration

USAGE:
  wt <subcommand> [options]

PRIMARY TMUX WORKFLOW COMMANDS:
  These commands create/manage worktrees AND handle tmux windows for you.
  Use these for your normal workflow.

  wt new <branch> [base]         Create new branch and open in tmux
  wt open <branch>               Open existing branch in tmux
  wt close [options] [branch]    Close tmux window and remove worktree
  wt merge [options] [branch]    Rebase, merge to master, close worktree, delete branch

NAVIGATION & INFO:
  wt list                        List all worktrees
  wt cd [branch]                 Navigate to worktree directory
  wt status                      Show current worktree info
  wt update [branch]             Fetch master and rebase current/specified branch

LOW-LEVEL WORKTREE COMMANDS (no tmux):
  These commands only manage worktrees without any tmux integration.
  Use these when you want manual control over tmux or no tmux at all.

  wt add <branch>                Add existing branch as worktree
  wt add -b <branch> [base]      Create new branch as worktree
  wt remove <branch>             Remove worktree only

OPTIONS:
  wt close -d [branch]           Remove worktree and DELETE branch
  wt close --delete [branch]     Long form of -d
  wt merge -k [branch]           Keep branch after merge (default: delete)
  wt merge --keep [branch]       Long form of -k

ENVIRONMENT VARIABLES:
  Customize tmux layout and commands:

  WT_EDITOR                      Editor to open (default: nvim)
  WT_ASSISTANT                   Assistant/AI tool (default: claude --dangerously-skip-permissions)
  WT_TERMINAL_CMD                Command to run in terminal pane (default: none)
  WT_PANE_WIDTH                  Right pane width percentage (default: 40)
EOF
}

# Create new branch and open in tmux
function _wt_new() {
  local branch_name="$1"
  local from_branch="$2"

  if [[ -z "$branch_name" ]]; then
    echo "Error: Branch name required"
    echo "Usage: wt new <branch-name> [base-branch]"
    echo ""
    echo "Examples:"
    echo "  wt new feature/auth          # Create from current HEAD"
    echo "  wt new feature/auth main     # Create from main"
    return 1
  fi

  # Check if worktree already exists
  local existing_worktree=$(wtp list 2>/dev/null | tail -n +3 | awk -v branch="$branch_name" '$2 == branch {print $1}' | sed 's/[\*@]$//')

  if [[ -n "$existing_worktree" ]]; then
    echo "Error: Worktree already exists for branch: $branch_name"
    echo "Use 'wt open $branch_name' to open the existing worktree"
    return 1
  fi

  # Create worktree with new branch
  echo "Creating new branch and worktree: $branch_name"
  if [[ -n "$from_branch" ]]; then
    wtp add -b "$branch_name" "$from_branch" || return 1
  else
    wtp add -b "$branch_name" || return 1
  fi

  # Get worktree path - wait a moment for worktree to be fully created
  sleep 0.5

  # Parse git worktree list to get the absolute path
  local worktree_path=$(git worktree list | grep "\[$branch_name\]" | awk '{print $1}')

  if [[ -z "$worktree_path" ]]; then
    echo "Error: Could not determine worktree path for branch: $branch_name"
    return 1
  fi

  # Open in tmux
  _wt_open_tmux "$branch_name" "$worktree_path"
}

# Open existing branch in tmux
function _wt_open() {
  local branch_name="$1"

  if [[ -z "$branch_name" ]]; then
    echo "Error: Branch name required"
    echo "Usage: wt open <branch-name>"
    echo ""
    echo "Examples:"
    echo "  wt open feature/auth"
    return 1
  fi

  # Check if worktree already exists
  local existing_worktree=$(wtp list 2>/dev/null | tail -n +3 | awk -v branch="$branch_name" '$2 == branch {print $1}' | sed 's/[\*@]$//')

  if [[ -n "$existing_worktree" ]]; then
    echo "Worktree already exists for branch: $branch_name"
    # Parse git worktree list to get the absolute path
    worktree_path=$(git worktree list | grep "\[$branch_name\]" | awk '{print $1}')
  else
    # Create worktree from existing branch
    echo "Creating worktree from existing branch: $branch_name"
    wtp add "$branch_name" || return 1

    # Get worktree path - wait a moment for worktree to be fully created
    sleep 0.5

    # Parse git worktree list to get the absolute path
    worktree_path=$(git worktree list | grep "\[$branch_name\]" | awk '{print $1}')
  fi

  if [[ -z "$worktree_path" ]]; then
    echo "Error: Could not determine worktree path for branch: $branch_name"
    return 1
  fi

  # Open in tmux
  _wt_open_tmux "$branch_name" "$worktree_path"
}

# Helper function to open worktree in tmux
function _wt_open_tmux() {
  local branch_name="$1"
  local worktree_path="$2"

  # Configurable via environment variables
  local editor="${WT_EDITOR:-nvim}"
  local assistant="${WT_ASSISTANT:-claude --dangerously-skip-permissions}"
  local terminal="${WT_TERMINAL_CMD:-}"
  local pane_width="${WT_PANE_WIDTH:-40}"

  echo "Opening tmux environment at: $worktree_path"

  # Verify the path exists
  if [[ ! -d "$worktree_path" ]]; then
    echo "Warning: Worktree path does not exist: $worktree_path"
    return 1
  fi

  # Check if we're in a tmux session
  if [[ -z "$TMUX" ]]; then
    echo "Not in tmux session. Starting new session..."
    tmux new-session -s "wt-$(basename $branch_name)" -c "$worktree_path" \; \
      send-keys "$editor" Enter \; \
      split-window -h -c "$worktree_path" \; \
      split-window -v -c "$worktree_path" \; \
      send-keys "$assistant" Enter \; \
      select-pane -t 1

    # Run terminal command if specified
    if [[ -n "$terminal" ]]; then
      tmux select-pane -t 1 \; send-keys "$terminal" Enter
    fi
    return
  fi

  # We're in tmux, create new window with layout
  local window_name="wt-$(basename $branch_name)"

  tmux new-window -n "$window_name" \; \
    send-keys "cd \"$worktree_path\" && $editor" Enter \; \
    split-window -h -p "$pane_width" \; \
    send-keys "cd \"$worktree_path\"" Enter \; \
    split-window -v \; \
    send-keys "cd \"$worktree_path\" && $assistant" Enter \; \
    select-pane -t 0

  # Run terminal command if specified
  if [[ -n "$terminal" ]]; then
    tmux select-pane -t 1 \; send-keys "$terminal" Enter
  fi
}

# Close tmux window and remove worktree
function _wt_close() {
  local delete_branch=false
  local branch_name=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -d|--delete)
        delete_branch=true
        shift
        ;;
      *)
        branch_name="$1"
        shift
        ;;
    esac
  done

  # If no branch specified, try to get current branch
  if [[ -z "$branch_name" ]]; then
    branch_name=$(git branch --show-current 2>/dev/null)
    if [[ -z "$branch_name" ]]; then
      echo "Error: Not in a git repository or could not determine branch"
      echo "Usage: wt close [-d|--delete] [branch-name]"
      return 1
    fi
    echo "Using current branch: $branch_name"
  fi

  # Get the worktree path
  local worktree_path=$(git worktree list | grep "\[$branch_name\]" | awk '{print $1}')

  if [[ -z "$worktree_path" ]]; then
    echo "Error: No worktree found for branch: $branch_name"
    return 1
  fi

  # Close tmux window if we're in tmux and in this worktree
  if [[ -n "$TMUX" ]]; then
    local current_path=$(pwd)
    # Check if current directory is inside the worktree
    if [[ "$current_path" == "$worktree_path"* ]]; then
      echo "Closing tmux window..."
      tmux kill-window
    else
      # Try to find and close the window by name
      local window_name="wt-$(basename $branch_name)"
      tmux kill-window -t "$window_name" 2>/dev/null && echo "Closed tmux window: $window_name"
    fi
  fi

  # Remove the worktree
  if [[ "$delete_branch" == true ]]; then
    echo "Removing worktree and deleting branch: $branch_name"
    wtp remove --with-branch "$branch_name"
  else
    echo "Removing worktree: $branch_name (keeping branch)"
    wtp remove "$branch_name"
  fi
}

# List all worktrees
function _wt_list() {
  wtp list
}

# Navigate to worktree
function _wt_cd() {
  if [[ -z "$1" ]]; then
    # Go to main worktree
    cd "$(git rev-parse --show-toplevel 2>/dev/null || echo .)"
  else
    local worktree_path=$(git worktree list | grep "\[$1\]" | awk '{print $1}')
    if [[ -n "$worktree_path" ]]; then
      cd "$worktree_path"
    else
      echo "Error: No worktree found for branch: $1"
      return 1
    fi
  fi
}

# Low-level: Add worktree without tmux
function _wt_add() {
  wtp add "$@"
}

# Low-level: Remove worktree without tmux
function _wt_remove() {
  wtp remove "$@"
}

# Show current worktree status
function _wt_status() {
  local branch_name=$(git branch --show-current 2>/dev/null)

  if [[ -z "$branch_name" ]]; then
    echo "Error: Not in a git repository or could not determine branch"
    return 1
  fi

  local worktree_path=$(git worktree list | grep "\[$branch_name\]" | awk '{print $1}')
  local is_main=$(git worktree list | head -1 | grep -q "\[$branch_name\]" && echo "yes" || echo "no")

  echo "Current worktree status:"
  echo "  Branch: $branch_name"
  echo "  Path: ${worktree_path:-$(git rev-parse --show-toplevel)}"
  echo "  Main worktree: $is_main"

  if [[ -n "$TMUX" ]]; then
    local window_name=$(tmux display-message -p '#W')
    echo "  Tmux window: $window_name"
  fi
}

# Update worktree by fetching master and rebasing
function _wt_update() {
  local target_branch="$1"
  local original_dir=$(pwd)
  local worktree_path=""

  # If no branch specified, use current branch
  if [[ -z "$target_branch" ]]; then
    target_branch=$(git branch --show-current 2>/dev/null)
    if [[ -z "$target_branch" ]]; then
      echo "Error: Not in a git repository or could not determine branch"
      return 1
    fi
    echo "Updating current branch: $target_branch"
    worktree_path=$(pwd)
  else
    # Get worktree path for specified branch
    worktree_path=$(git worktree list | grep "\[$target_branch\]" | awk '{print $1}')
    if [[ -z "$worktree_path" ]]; then
      echo "Error: No worktree found for branch: $target_branch"
      return 1
    fi
    echo "Updating branch: $target_branch"
    cd "$worktree_path" || return 1
  fi

  # Fetch remote master branch
  echo "Fetching origin/master..."
  git fetch origin master || {
    echo "Error: Failed to fetch master"
    cd "$original_dir"
    return 1
  }

  # Rebase against origin/master
  echo "Rebasing $target_branch against origin/master..."
  git rebase origin/master || {
    echo ""
    echo "Error: Rebase failed. You may need to resolve conflicts."
    echo "Run 'git rebase --abort' to cancel or resolve conflicts and 'git rebase --continue'"
    cd "$original_dir"
    return 1
  }

  echo "✓ Successfully updated $target_branch with latest master"

  # Return to original directory if we changed it
  if [[ "$original_dir" != "$worktree_path" ]]; then
    cd "$original_dir"
  fi
}

# Merge worktree back to master
function _wt_merge() {
  local keep_branch=false
  local branch_name=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -k|--keep)
        keep_branch=true
        shift
        ;;
      *)
        branch_name="$1"
        shift
        ;;
    esac
  done

  # If no branch specified, try to get current branch
  if [[ -z "$branch_name" ]]; then
    branch_name=$(git branch --show-current 2>/dev/null)
    if [[ -z "$branch_name" ]]; then
      echo "Error: Not in a git repository or could not determine branch"
      echo "Usage: wt merge [-k|--keep] [branch-name]"
      return 1
    fi

    # Check if we're on master/main
    if [[ "$branch_name" == "master" || "$branch_name" == "main" ]]; then
      echo "Error: Cannot merge master into itself"
      echo "Usage: wt merge [-k|--keep] <branch-name>"
      return 1
    fi

    echo "Merging current branch: $branch_name"
  fi

  # Get the worktree path for the feature branch
  local feature_worktree_path=$(git worktree list | grep "\[$branch_name\]" | awk '{print $1}')

  if [[ -z "$feature_worktree_path" ]]; then
    echo "Error: No worktree found for branch: $branch_name"
    return 1
  fi

  # Get the main worktree path (first line of git worktree list)
  local main_worktree_path=$(git worktree list | head -1 | awk '{print $1}')
  local main_branch=$(git worktree list | head -1 | grep -o '\[.*\]' | tr -d '[]')

  echo "Step 1: Rebasing $branch_name onto origin/master..."
  _wt_update "$branch_name" || {
    echo "Error: Rebase failed. Aborting merge."
    return 1
  }

  echo ""
  echo "Step 2: Switching to main worktree at: $main_worktree_path"
  cd "$main_worktree_path" || {
    echo "Error: Could not switch to main worktree"
    return 1
  }

  # Make sure we're on the main branch
  if [[ "$(git branch --show-current)" != "$main_branch" ]]; then
    echo "Checking out $main_branch..."
    git checkout "$main_branch" || {
      echo "Error: Could not checkout $main_branch"
      return 1
    }
  fi

  # Update main branch to match origin/master
  echo "Updating $main_branch to latest from origin..."
  git merge --ff-only origin/master || {
    echo ""
    echo "Error: Could not fast-forward $main_branch to origin/master"
    echo "Your local $main_branch has diverged from origin/master"
    echo "Please resolve this manually before merging"
    return 1
  }

  echo ""
  echo "Step 3: Merging $branch_name into $main_branch..."
  git merge "$branch_name" || {
    echo ""
    echo "Error: Merge failed. Resolve conflicts manually."
    echo "After resolving, run:"
    echo "  git merge --continue"
    echo "  wt close $branch_name"
    return 1
  }

  echo ""
  echo "Step 4: Closing worktree..."
  if [[ "$keep_branch" == true ]]; then
    echo "Removing worktree: $branch_name (keeping branch)"
    wtp remove "$branch_name"
  else
    echo "Removing worktree and deleting branch: $branch_name"
    wtp remove --with-branch "$branch_name"
  fi

  # Close tmux window if we're in tmux
  if [[ -n "$TMUX" ]]; then
    local window_name="wt-$(basename $branch_name)"
    tmux kill-window -t "$window_name" 2>/dev/null && echo "Closed tmux window: $window_name"
  fi

  echo ""
  echo "✓ Successfully merged $branch_name into $main_branch"
  echo ""
  echo "Next steps:"
  echo "  git push origin $main_branch"
}

# Zsh completion function for wt
function _wt_completion() {
  local -a subcommands
  subcommands=(
    # PRIMARY TMUX WORKFLOW COMMANDS
    'new:[tmux] Create new branch and open in tmux window'
    'open:[tmux] Open existing branch in tmux window'
    'close:[tmux] Close tmux window and remove worktree'
    'merge:[tmux] Rebase onto master, merge, close worktree, delete branch'

    # NAVIGATION & INFO
    'list:List all worktrees'
    'cd:Navigate to worktree directory'
    'status:Show current worktree status'
    'update:Fetch master and rebase current or specified branch'

    # LOW-LEVEL WORKTREE COMMANDS (no tmux)
    'add:[low-level] Add worktree without opening tmux'
    'remove:[low-level] Remove worktree without closing tmux'

    # HELP
    'help:Show detailed help information'
  )

  local curcontext="$curcontext" state line
  typeset -A opt_args

  _arguments -C \
    '1: :->subcommand' \
    '*: :->args'

  case $state in
    subcommand)
      _describe -V 'wt subcommand' subcommands
      ;;
    args)
      case $line[1] in
        new)
          # For 'new', show all branches as reference for base branch (second arg)
          if [[ $CURRENT -eq 3 ]]; then
            _wt_complete_all_branches
          fi
          ;;
        open|add)
          # Show all branches
          _wt_complete_all_branches
          ;;
        close|remove|cd|update|merge)
          # First check for flags
          if [[ $words[$CURRENT] == -* ]]; then
            if [[ $line[1] == "close" ]]; then
              local -a close_opts
              close_opts=(
                '-d:Delete branch along with worktree'
                '--delete:Delete branch along with worktree'
              )
              _describe 'options' close_opts
            elif [[ $line[1] == "merge" ]]; then
              local -a merge_opts
              merge_opts=(
                '-k:Keep branch after merge'
                '--keep:Keep branch after merge'
              )
              _describe 'options' merge_opts
            fi
          else
            # Show only branches with worktrees
            _wt_complete_worktree_branches
          fi
          ;;
      esac
      ;;
  esac
}

# Helper: Complete all git branches
function _wt_complete_all_branches() {
  local -a branches
  branches=(${(f)"$(git branch --format='%(refname:short)' 2>/dev/null)"})
  _describe 'branch' branches
}

# Helper: Complete only branches that have worktrees
function _wt_complete_worktree_branches() {
  local -a worktree_branches
  # Extract branch names from git worktree list (they appear in brackets)
  worktree_branches=(${(f)"$(git worktree list 2>/dev/null | grep -o '\[.*\]' | tr -d '[]')"})
  if [[ ${#worktree_branches[@]} -gt 0 ]]; then
    _describe 'worktree branch' worktree_branches
  fi
}

# Register completion function (only if compdef is available)
if command -v compdef &>/dev/null; then
  compdef _wt_completion wt
fi
