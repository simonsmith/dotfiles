# Unified worktree + tmux management
# Requires: wtp (https://github.com/satococoa/wtp)

# Main wt dispatcher function
function wt() {
  if [[ $# -eq 0 ]]; then
    _wt_help
    return 0
  fi

  local subcommand="$1"
  shift

  case "$subcommand" in
    help|--help|-h)
      _wt_help
      return 0
      ;;
    new|open|close|list|cd|add|remove|sync|merge)
      _wt_require_repo || return 1
      ;;
    *)
      echo "Error: Unknown subcommand '$subcommand'"
      echo ""
      echo "Run 'wt help' for usage information"
      return 1
      ;;
  esac

  case "$subcommand" in
    new)
      _wt_new "$@"
      ;;
    open)
      _wt_open "$@"
      ;;
    close)
      _wt_close "$@"
      ;;
    list)
      _wt_list "$@"
      ;;
    cd)
      _wt_cd "$@"
      ;;
    add)
      _wt_add "$@"
      ;;
    remove)
      _wt_remove "$@"
      ;;
    sync)
      _wt_sync "$@"
      ;;
    merge)
      _wt_merge "$@"
      ;;
  esac
}

# Show help and usage information
function _wt_help() {
  cat <<'EOF'
wt - Unified worktree management with tmux integration

USAGE:
  wt <subcommand> [options]

PRIMARY TMUX WORKFLOW COMMANDS:
  These commands create/manage worktrees AND handle tmux sessions for you.
  Each worktree gets its own dedicated session with 3 windows (edit, term, ai).
  Use these for your normal workflow.

  wt new <branch> [base]         Create new branch and open in tmux session
  wt open <branch>               Open existing branch in tmux session
  wt close [options] [branch]    Close tmux session and remove worktree
  wt merge [options] [branch]    Rebase, merge to default branch, close session, delete branch

NAVIGATION & INFO:
  wt list                        List all worktrees
  wt cd [branch]                 Navigate to worktree directory
  wt sync [branch]               Fetch default branch and rebase current/specified branch

LOW-LEVEL WORKTREE COMMANDS (no tmux):
  These commands only manage worktrees without any tmux integration.
  Use these when you want manual control over tmux or no tmux at all.

  wt add <branch>                Add existing branch as worktree
  wt add -b <branch> [base]      Create new branch as worktree
  wt remove <branch>             Remove worktree only

OPTIONS:
  wt close -d [branch]           Remove worktree and DELETE branch
  wt close --delete [branch]     Long form of -d
  wt merge -k [branch]           Keep branch after merge (default: delete)
  wt merge --keep [branch]       Long form of -k

ENVIRONMENT VARIABLES:
  Customize tmux windows and commands:

  WT_EDITOR                      Editor to open (default: nvim)
  WT_ASSISTANT                   Assistant/AI tool (default: codex)
  WT_TERMINAL_CMD                Command to run in terminal window
EOF
}

# Require a git repository
function _wt_require_repo() {
  git rev-parse --show-toplevel >/dev/null 2>&1 || {
    echo "Error: Not in a git repository"
    return 1
  }
}

# Determine the default branch (falls back to main worktree branch)
function _wt_default_branch() {
  local ref=""
  ref=$(git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null) || true
  if [[ -n "$ref" ]]; then
    echo "${ref#origin/}"
    return 0
  fi

  local main_branch=$(_wt_main_worktree_branch)
  if [[ -n "$main_branch" ]]; then
    echo "$main_branch"
    return 0
  fi

  return 1
}

# Main worktree path (first worktree entry)
function _wt_main_worktree_path() {
  local line=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        echo "${line#worktree }"
        return 0
        ;;
    esac
  done < <(git worktree list --porcelain 2>/dev/null)
  return 1
}

# Main worktree branch (first worktree entry)
function _wt_main_worktree_branch() {
  local line=""
  local in_first=0
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        if [[ $in_first -eq 0 ]]; then
          in_first=1
        else
          return 1
        fi
        ;;
      branch\ *)
        if [[ $in_first -eq 1 ]]; then
          local ref="${line#branch }"
          if [[ "$ref" == refs/heads/* ]]; then
            echo "${ref#refs/heads/}"
            return 0
          fi
          return 1
        fi
        ;;
      detached)
        if [[ $in_first -eq 1 ]]; then
          return 1
        fi
        ;;
    esac
  done < <(git worktree list --porcelain 2>/dev/null)
  return 1
}

# Find worktree path for a branch
function _wt_find_worktree_path() {
  local target_branch="$1"
  local line=""
  local path=""
  while IFS= read -r line; do
    case "$line" in
      worktree\ *)
        path="${line#worktree }"
        ;;
      branch\ *)
        if [[ "${line#branch }" == "refs/heads/$target_branch" ]]; then
          echo "$path"
          return 0
        fi
        ;;
    esac
  done < <(git worktree list --porcelain 2>/dev/null)
  return 1
}

# Wait for worktree to appear
function _wt_wait_for_worktree() {
  local target_branch="$1"
  local attempts=10
  local delay=0.1
  local path=""
  local i=1

  while (( i <= attempts )); do
    path=$(_wt_find_worktree_path "$target_branch")
    if [[ -n "$path" ]]; then
      echo "$path"
      return 0
    fi
    sleep "$delay"
    (( i++ ))
  done
  return 1
}

# List branches that have worktrees
function _wt_worktree_branches() {
  git worktree list --porcelain 2>/dev/null | awk '/^branch refs\/heads\// {sub("^branch refs/heads/",""); print}'
}

# Create new branch and open in tmux
function _wt_new() {
  local branch_name="$1"
  local from_branch="$2"

  if [[ -z "$branch_name" ]]; then
    echo "Error: Branch name required"
    echo "Usage: wt new <branch-name> [base-branch]"
    echo ""
    echo "Examples:"
    echo "  wt new feature/auth          # Create from current HEAD"
    echo "  wt new feature/auth main     # Create from main"
    return 1
  fi

  # Check if worktree already exists
  local existing_worktree=$(_wt_find_worktree_path "$branch_name")

  if [[ -n "$existing_worktree" ]]; then
    echo "Error: Worktree already exists for branch: $branch_name"
    echo "Use 'wt open $branch_name' to open the existing worktree"
    return 1
  fi

  # Create worktree with new branch
  echo "Creating new branch and worktree: $branch_name"
  if [[ -n "$from_branch" ]]; then
    wtp add -b "$branch_name" "$from_branch" || return 1
  else
    wtp add -b "$branch_name" || return 1
  fi

  # Get worktree path - wait for worktree to be fully created
  local worktree_path=$(_wt_wait_for_worktree "$branch_name")

  if [[ -z "$worktree_path" ]]; then
    echo "Error: Could not determine worktree path for branch: $branch_name"
    return 1
  fi

  # Open in tmux
  _wt_open_tmux "$branch_name" "$worktree_path"
}

# Open existing branch in tmux
function _wt_open() {
  local branch_name="$1"

  if [[ -z "$branch_name" ]]; then
    echo "Error: Branch name required"
    echo "Usage: wt open <branch-name>"
    echo ""
    echo "Examples:"
    echo "  wt open feature/auth"
    return 1
  fi

  # Check if worktree already exists
  local existing_worktree=$(_wt_find_worktree_path "$branch_name")
  local worktree_path=""

  if [[ -n "$existing_worktree" ]]; then
    echo "Worktree already exists for branch: $branch_name"
    worktree_path="$existing_worktree"
  else
    # Create worktree from existing branch
    echo "Creating worktree from existing branch: $branch_name"
    wtp add "$branch_name" || return 1

    # Get worktree path - wait for worktree to be fully created
    worktree_path=$(_wt_wait_for_worktree "$branch_name")
  fi

  if [[ -z "$worktree_path" ]]; then
    echo "Error: Could not determine worktree path for branch: $branch_name"
    return 1
  fi

  # Open in tmux
  _wt_open_tmux "$branch_name" "$worktree_path"
}

# Helper function to generate session name
function _wt_session_name() {
  local branch_name="$1"
  local repo_name=$(basename $(git rev-parse --show-toplevel 2>/dev/null))
  local safe_branch="${branch_name//\//_}"
  echo "wt-${repo_name}_${safe_branch}"
}

# Helper function to open worktree in tmux
function _wt_open_tmux() {
  local branch_name="$1"
  local worktree_path="$2"

  # Configurable via environment variables
  local editor="${WT_EDITOR:-nvim}"
  local assistant="${WT_ASSISTANT:-codex}"
  local terminal="${WT_TERMINAL_CMD:-}"

  echo "Opening tmux environment at: $worktree_path"

  # Verify the path exists
  if [[ ! -d "$worktree_path" ]]; then
    echo "Warning: Worktree path does not exist: $worktree_path"
    return 1
  fi

  local session_name=$(_wt_session_name "$branch_name")

  # Check if session already exists
  if tmux has-session -t "$session_name" 2>/dev/null; then
    echo "Session $session_name already exists, switching to it..."
    if [[ -n "$TMUX" ]]; then
      tmux switch-client -t "$session_name"
    else
      tmux attach-session -t "$session_name"
    fi
    return
  fi

  echo "Creating new tmux session: $session_name"

  # Create new session with multiple windows (always detached initially)
  tmux new-session -s "$session_name" -n "edit" -c "$worktree_path" -d \; \
    send-keys -t "$session_name":edit "$editor" Enter \; \
    new-window -t "$session_name" -n "term" -c "$worktree_path" \; \
    new-window -t "$session_name" -n "ai" -c "$worktree_path" \; \
    send-keys -t "$session_name":ai "$assistant" Enter \; \
    select-window -t "$session_name":edit

  # Run terminal command if specified in the term window
  if [[ -n "$terminal" ]]; then
    tmux select-window -t "$session_name":term \; \
      send-keys -t "$session_name":term "$terminal" Enter \; \
      select-window -t "$session_name":edit
  fi

  # Switch to or attach to the session
  if [[ -n "$TMUX" ]]; then
    # We're in tmux, switch to the new session
    tmux switch-client -t "$session_name"
  else
    # Not in tmux, attach to the session
    tmux attach-session -t "$session_name"
  fi
}

# Close tmux window and remove worktree
function _wt_close() {
  local delete_branch=false
  local branch_name=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -d|--delete)
        delete_branch=true
        shift
        ;;
      *)
        branch_name="$1"
        shift
        ;;
    esac
  done

  # If no branch specified, try to get current branch
  if [[ -z "$branch_name" ]]; then
    branch_name=$(git branch --show-current 2>/dev/null)
    if [[ -z "$branch_name" ]]; then
      echo "Error: Not in a git repository or could not determine branch"
      echo "Usage: wt close [-d|--delete] [branch-name]"
      return 1
    fi
    echo "Using current branch: $branch_name"
  fi

  # Get the worktree path
  local worktree_path=$(_wt_find_worktree_path "$branch_name")

  if [[ -z "$worktree_path" ]]; then
    echo "Error: No worktree found for branch: $branch_name"
    return 1
  fi

  # Prevent closing the main worktree
  local main_worktree_path=$(_wt_main_worktree_path)
  if [[ -n "$main_worktree_path" && "$worktree_path" == "$main_worktree_path" ]]; then
    echo "Error: Refusing to close the main worktree"
    return 1
  fi

  # Close tmux session
  local session_name=$(_wt_session_name "$branch_name")

  # Check if a session exists for this worktree
  if tmux has-session -t "$session_name" 2>/dev/null; then
    echo "Killing tmux session: $session_name"
    tmux kill-session -t "$session_name"
  fi

  # Remove the worktree
  if [[ "$delete_branch" == true ]]; then
    echo "Removing worktree and deleting branch: $branch_name"
    wtp remove --with-branch "$branch_name"
  else
    echo "Removing worktree: $branch_name (keeping branch)"
    wtp remove "$branch_name"
  fi
}

# List all worktrees
function _wt_list() {
  wtp list
}

# Navigate to worktree
function _wt_cd() {
  if [[ -z "$1" ]]; then
    # Go to main worktree
    local target_dir=$(command wtp cd 2>/dev/null)
    if [[ $? -eq 0 && -n "$target_dir" ]]; then
      cd "$target_dir"
    else
      command wtp cd
    fi
  else
    local target_dir=$(command wtp cd "$1" 2>/dev/null)
    if [[ $? -eq 0 && -n "$target_dir" ]]; then
      cd "$target_dir"
    else
      command wtp cd "$1"
    fi
  fi
}

# Low-level: Add worktree without tmux
function _wt_add() {
  wtp add "$@"
}

# Low-level: Remove worktree without tmux
function _wt_remove() {
  wtp remove "$@"
}


# Sync worktree by fetching default branch and rebasing
function _wt_sync() {
  local target_branch="$1"
  local original_dir=$(pwd)
  local worktree_path=""
  local default_branch=$(_wt_default_branch)

  if [[ -z "$default_branch" ]]; then
    echo "Error: Could not determine default branch (origin/HEAD not set)"
    return 1
  fi

  # If no branch specified, use current branch
  if [[ -z "$target_branch" ]]; then
    target_branch=$(git branch --show-current 2>/dev/null)
    if [[ -z "$target_branch" ]]; then
      echo "Error: Not in a git repository or could not determine branch"
      return 1
    fi
    echo "Updating current branch: $target_branch"
    worktree_path=$(pwd)
  else
    # Get worktree path for specified branch
    worktree_path=$(_wt_find_worktree_path "$target_branch")
    if [[ -z "$worktree_path" ]]; then
      echo "Error: No worktree found for branch: $target_branch"
      return 1
    fi
    echo "Updating branch: $target_branch"
    cd "$worktree_path" || return 1
  fi

  # Fetch remote default branch
  echo "Fetching origin/$default_branch..."
  git fetch origin "$default_branch" || {
    echo "Error: Failed to fetch $default_branch"
    cd "$original_dir"
    return 1
  }

  # Rebase against origin/default
  echo "Rebasing $target_branch against origin/$default_branch..."
  git rebase "origin/$default_branch" || {
    echo ""
    echo "Error: Rebase failed. You may need to resolve conflicts."
    echo "Run 'git rebase --abort' to cancel or resolve conflicts and 'git rebase --continue'"
    cd "$original_dir"
    return 1
  }

  echo "✓ Successfully updated $target_branch with latest $default_branch"

  # Return to original directory if we changed it
  if [[ "$original_dir" != "$worktree_path" ]]; then
    cd "$original_dir"
  fi
}

# Merge worktree back to default branch
function _wt_merge() {
  local keep_branch=false
  local branch_name=""

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case $1 in
      -k|--keep)
        keep_branch=true
        shift
        ;;
      *)
        branch_name="$1"
        shift
        ;;
    esac
  done

  # If no branch specified, try to get current branch
  if [[ -z "$branch_name" ]]; then
    branch_name=$(git branch --show-current 2>/dev/null)
    if [[ -z "$branch_name" ]]; then
      echo "Error: Not in a git repository or could not determine branch"
      echo "Usage: wt merge [-k|--keep] [branch-name]"
      return 1
    fi

    echo "Merging current branch: $branch_name"
  fi

  local default_branch=$(_wt_default_branch)
  if [[ -z "$default_branch" ]]; then
    echo "Error: Could not determine default branch (origin/HEAD not set)"
    return 1
  fi

  if [[ "$branch_name" == "$default_branch" ]]; then
    echo "Error: Cannot merge $default_branch into itself"
    echo "Usage: wt merge [-k|--keep] <branch-name>"
    return 1
  fi

  # Get the worktree path for the feature branch
  local feature_worktree_path=$(_wt_find_worktree_path "$branch_name")

  if [[ -z "$feature_worktree_path" ]]; then
    echo "Error: No worktree found for branch: $branch_name"
    return 1
  fi

  # Get the main worktree path (first worktree entry)
  local main_worktree_path=$(_wt_main_worktree_path)
  if [[ -z "$main_worktree_path" ]]; then
    echo "Error: Could not determine main worktree path"
    return 1
  fi

  if [[ "$feature_worktree_path" == "$main_worktree_path" ]]; then
    echo "Error: Refusing to merge from the main worktree"
    return 1
  fi

  echo "Step 1: Rebasing $branch_name onto origin/$default_branch..."
  _wt_sync "$branch_name" || {
    echo "Error: Rebase failed. Aborting merge."
    return 1
  }

  echo ""
  echo "Step 2: Switching to main worktree at: $main_worktree_path"
  cd "$main_worktree_path" || {
    echo "Error: Could not switch to main worktree"
    return 1
  }

  # Make sure we're on the default branch
  if [[ "$(git branch --show-current)" != "$default_branch" ]]; then
    echo "Checking out $default_branch..."
    git checkout "$default_branch" || {
      echo "Error: Could not checkout $default_branch"
      return 1
    }
  fi

  # Update default branch to match origin
  echo "Updating $default_branch to latest from origin..."
  git merge --ff-only "origin/$default_branch" || {
    echo ""
    echo "Error: Could not fast-forward $default_branch to origin/$default_branch"
    echo "Your local $default_branch has diverged from origin/$default_branch"
    echo "Please resolve this manually before merging"
    return 1
  }

  echo ""
  echo "Step 3: Merging $branch_name into $default_branch..."
  git merge "$branch_name" || {
    echo ""
    echo "Error: Merge failed. Resolve conflicts manually."
    echo "After resolving, run:"
    echo "  git merge --continue"
    echo "  wt close $branch_name"
    return 1
  }

  echo ""
  echo "Step 4: Closing worktree..."
  if [[ "$keep_branch" == true ]]; then
    echo "Removing worktree: $branch_name (keeping branch)"
    wtp remove "$branch_name"
  else
    echo "Removing worktree and deleting branch: $branch_name"
    wtp remove --with-branch "$branch_name"
  fi

  # Close tmux session
  local session_name=$(_wt_session_name "$branch_name")

  # Check if a session exists for this worktree
  if tmux has-session -t "$session_name" 2>/dev/null; then
    echo "Killing tmux session: $session_name"
    tmux kill-session -t "$session_name"
  fi

  echo ""
  echo "✓ Successfully merged $branch_name into $main_branch"
  echo ""
  echo "Next steps:"
  echo "  git push origin $main_branch"
}

# Zsh completion function for wt
function _wt_completion() {
  local -a subcommands
  subcommands=(
    # PRIMARY TMUX WORKFLOW COMMANDS
    'new:[tmux] Create new branch and open in dedicated tmux session'
    'open:[tmux] Open existing branch in dedicated tmux session'
    'close:[tmux] Close tmux session and remove worktree'
    'merge:[tmux] Rebase onto default branch, merge, close session, delete branch'

    # NAVIGATION & INFO
    'list:List all worktrees'
    'cd:Navigate to worktree directory'
    'sync:Fetch default branch and rebase current or specified branch'

    # WTP PASS-THROUGH COMMANDS
    'add:Add worktree'
    'remove:Remove worktree'

    # HELP
    'help:Show detailed help information'
  )

  local curcontext="$curcontext" state line
  typeset -A opt_args

  _arguments -C \
    '1: :->subcommand' \
    '*: :->args'

  case $state in
    subcommand)
      _describe -V 'wt subcommand' subcommands
      ;;
    args)
      case $line[1] in
        new)
          # For 'new', show all branches as reference for base branch (second arg)
          if [[ $CURRENT -eq 3 ]]; then
            _wt_complete_all_branches
          fi
          ;;
        open|add)
          # Show all branches
          _wt_complete_all_branches
          ;;
        close|remove|cd|sync|merge)
          # First check for flags
          if [[ $words[$CURRENT] == -* ]]; then
            if [[ $line[1] == "close" ]]; then
              local -a close_opts
              close_opts=(
                '-d:Delete branch along with worktree'
                '--delete:Delete branch along with worktree'
              )
              _describe 'options' close_opts
            elif [[ $line[1] == "merge" ]]; then
              local -a merge_opts
              merge_opts=(
                '-k:Keep branch after merge'
                '--keep:Keep branch after merge'
              )
              _describe 'options' merge_opts
            fi
          else
            # Show only branches with worktrees
            _wt_complete_worktree_branches
          fi
          ;;
      esac
      ;;
  esac
}

# Helper: Complete all git branches
function _wt_complete_all_branches() {
  local -a branches
  branches=(${(f)"$(git branch --format='%(refname:short)' 2>/dev/null)"})
  _describe 'branch' branches
}

# Helper: Complete only branches that have worktrees
function _wt_complete_worktree_branches() {
  local -a worktree_branches
  # Extract branch names from porcelain output
  worktree_branches=(${(f)"$(_wt_worktree_branches)"})
  if [[ ${#worktree_branches[@]} -gt 0 ]]; then
    _describe 'worktree branch' worktree_branches
  fi
}

# Register completion function (only if compdef is available)
if command -v compdef &>/dev/null; then
  compdef _wt_completion wt
fi
